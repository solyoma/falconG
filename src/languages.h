#pragma once

#include <QMainWindow>
#include <QString>
#include <QStringList>

const QString sFalcongEnglishCopyright = QString(QMainWindow::tr("Site generated by\n<strong>falconG</strong> - © A.Sólyom 2018-2024"));

//*****************************************
class LangConstList : public QStringList	 // texts for each languages
{
	int _index;		// item index
	QString _def;	// description of what this is
public:	
	LangConstList(int index, QString definition, int size = 0) : QStringList(), _index(index), _def(definition) { Prepare(size); }

	int Index() const { return _index; }
	QString Definition() const { return _def; }
	void Prepare(int languageCount) { clear();  for (int i = 0; i < languageCount; ++i) push_back(""); }
	void Clear() { for (int i = 0; i < size(); ++i) (*this)[i].clear(); }
	bool IsEmpty() {for (int i = 0; i < size(); ++i) if (!(*this)[i].isEmpty()) return false; return true;}
	void Fill(QString s) { for (int i = 0; i < size(); ++i) (*this)[i] = s; }

    LangConstList &operator=(const LangConstList & txt) { QStringList::operator=(dynamic_cast<const QStringList &>(txt)); return *this;}
    LangConstList &operator=(const QStringList &sl) { QStringList::operator=(sl);  return *this;}
};
//*****************************************

using LanguageMap = QMap<QString, LangConstList*>;

struct Languages : public LanguageMap	// each language has a text file named <text from 'languages'>.lang
{					// an the languages are also set in a .struct file
		// these are read from language definition files '<xxx>.lang in program directory

	Languages();
	~Languages();

	int _Read(QString name);		// defult: single language, name: "English" countryCode: "en_US", no icon
	int Read();					// reads all language files from program directory
	void Clear(int newSize = 0);
	int LanguageCount()
	{
		return first()->size();
	}
	void SetTextFor(QString name, QString val, int lang);

	QString FileNameForLanguage(QString name, int language);	// adds _<abbrev> to base name if more than one languages
};

//------------------------------------------
class TextMap;			// in albums.h, used in text for ID calculation

/*============================================================================
* LanguageTexts and TextMap
*	- LanguageTexts objects contains the concatenated texts for all languages
*	- Texts are represented by their ID, which may not be 0
*	- text IDs are calculated using all language texts. This is the base ID
*	- two or more texts may have the same base ID but different QStrings in
*		them (text ID collision)
*	  in which case the ID of the new text (the one that was added later on)
*		is modified using the 'collision' member, which is
*			1 + the number of the other texts with the same base ID
*	- the usage count of each text is the number of Albums and Images that
*		use it. If 'usageCount' is 0 thex is not used anywhere
*	- More than one Album or Image can use the same text, or more accurately the
*	  same text ID
*
*----------------------------------------------------------------------------*/

struct LanguageTexts				// both Album and Image uses this
{
	int64_t ID = 0;		// same for all translations of this in all languages (0: invalid)
	int collision = -1;	// (-1: not set) set when this text collided with an other one: ID = base id + (collision << TEXT_ID_COLLISION_FACTOR)
	QVector<int> lenghts;	// set to have as many elements as there are languages, lang ID is index in text
	QString textsForAllLanguages; //concatenated language texts
	UsageCount usageCount; // how many times this same text is added to list

	LanguageTexts(int languageCount = 0) { Clear(languageCount); }
	LanguageTexts(const QStringList& texts);
	LanguageTexts(const LanguageTexts& t) : ID(t.ID), collision(t.collision), lenghts(t.lenghts), textsForAllLanguages(t.textsForAllLanguages), usageCount(t.usageCount) {}

	int Count()const { return lenghts.size(); }

	LanguageTexts& operator=(const LanguageTexts& t);
	LanguageTexts& operator=(const QStringList& txts);
	bool operator==(const LanguageTexts& t);		// compare first ID then all texts
	bool operator!=(const LanguageTexts& t);		// compare first ID then lang (unless lang < 0, when only ID is used)
	int operator<(const LanguageTexts& t);

	const QString operator[](int index) const			   // ***  can't change text using this! Use SetText() instead
	{
		static QString dummy;
		if (textsForAllLanguages.isEmpty())
			return dummy;
		if (index == 0)
			return textsForAllLanguages.left(lenghts[0]);
		return (index > 0 && index < lenghts.size()) ? textsForAllLanguages.mid(lenghts[index - 1], lenghts[index]) : dummy;
	}
	void SetTextForLanguageNoID(const QString str, int lang);		 // just set

	bool Valid() const { return ID > 0; }
	int64_t CalcBaseID();			// changes 'ID' but does not change 'collision'
	int64_t CalcID(TextMap& map);	// changes 'ID' and 'collision' unless already OK (read in)

	void Clear(int newSize = 0);  // 0: does not change size of 'lenghts'
	bool IsEmpty() { return textsForAllLanguages.isEmpty(); }
};


//------------------------------------------
class TextMap : public QMap<int64_t, LanguageTexts>
{
	static LanguageTexts invalid;
public:
	LanguageTexts* Find(int64_t id);
	LanguageTexts* Find(QString text, int lang);
	LanguageTexts* Find(const QStringList& texts);
	int Collision(LanguageTexts& text, int& usageCount) const;		// do not add when text is the same
	int64_t Add(QStringList& texts, bool& added);	// add unique text, returns ID and if added
	int64_t Add(LanguageTexts& text, bool& added);			// add based on ID and lang and text
	void Remove(int64_t id);					// decrements usage count and removes text if it is 0
};



extern Languages languages;